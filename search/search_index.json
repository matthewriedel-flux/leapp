{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Welcome to Leapp Leapp is a tool for developers to manage, secure, and access to the cloud. All data is persisted and encrypted on your workstation . Head to our Security section to know how we guarantee the highest level of security. Leapp Main Window The name Leapp is inspired by the English word leap and pronounced /l:ip/ . We choose this name because the project enables you to be one step away from your cloud environments.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#welcome-to-leapp","text":"Leapp is a tool for developers to manage, secure, and access to the cloud. All data is persisted and encrypted on your workstation . Head to our Security section to know how we guarantee the highest level of security. Leapp Main Window The name Leapp is inspired by the English word leap and pronounced /l:ip/ . We choose this name because the project enables you to be one step away from your cloud environments.","title":"Welcome to Leapp"},{"location":"configuration/","text":"Now it's time to add your very first configuration, follow the link to your preferred supported method and start enjoying Leapp. Sessions AWS Configure an AWS IAM User Configure an AWS IAM Role Federated Configure an AWS IAM Role Chained Azure Configure an Azure Tenant Integrations Configure AWS SSO","title":"Add your first configuration"},{"location":"configuration/#sessions","text":"","title":"Sessions"},{"location":"configuration/#aws","text":"","title":"AWS"},{"location":"configuration/#configure-an-aws-iam-user","text":"","title":"Configure an AWS IAM User"},{"location":"configuration/#configure-an-aws-iam-role-federated","text":"","title":"Configure an AWS IAM Role Federated"},{"location":"configuration/#configure-an-aws-iam-role-chained","text":"","title":"Configure an AWS IAM Role Chained"},{"location":"configuration/#azure","text":"","title":"Azure"},{"location":"configuration/#configure-an-azure-tenant","text":"","title":"Configure an Azure Tenant"},{"location":"configuration/#integrations","text":"","title":"Integrations"},{"location":"configuration/#configure-aws-sso","text":"","title":"Configure AWS SSO"},{"location":"integrations/","text":"This section provides an overview of Leapp's integrations, useful to extend the functionality of Leapp to 3rd party services. Integrations help manage access and identities on your preferred service of choice and use Leapp on your daily activities by automatically mapping them into Sessions . Actions Integrations have four main actions available: Create Delete , Sync , and Logout . Action Description CREATE Configure a new Integration with the data needed to start the authentication flow. Required to Sync and map the service response into Sessions. DELETE Remove an existing Integration. Also removes all the associated Sessions and wipes from the system everything related to it (Sessions, tokens, cache, etc.) SYNC Start the authentication flow to log into the Integration Provider. Leapp will automatically retrieve all the related data and map the response into Sessions. Any change in your service of choice, require a manual Sync to reflect the current status. LOGOUT Disable the Integration. Removes all the Sessions but keep the Integration data. Running a Sync will restore all Sessions tied to it. Supported Services Service Supported AWS SSO Okta Coming Soon OneLogin Coming Soon AzureAD Coming Soon","title":"Integrations"},{"location":"integrations/#actions","text":"Integrations have four main actions available: Create Delete , Sync , and Logout . Action Description CREATE Configure a new Integration with the data needed to start the authentication flow. Required to Sync and map the service response into Sessions. DELETE Remove an existing Integration. Also removes all the associated Sessions and wipes from the system everything related to it (Sessions, tokens, cache, etc.) SYNC Start the authentication flow to log into the Integration Provider. Leapp will automatically retrieve all the related data and map the response into Sessions. Any change in your service of choice, require a manual Sync to reflect the current status. LOGOUT Disable the Integration. Removes all the Sessions but keep the Integration data. Running a Sync will restore all Sessions tied to it.","title":"Actions"},{"location":"integrations/#supported-services","text":"Service Supported AWS SSO Okta Coming Soon OneLogin Coming Soon AzureAD Coming Soon","title":"Supported Services"},{"location":"roadmap/","text":"Leapp 2021 Q4 Milestone Description AWS GOTO Console Open links to online console for AWS AWS External IDs Support AWS External IDS in Sessions AWS Export to ENV Export temporary credentials to environment variables (inject in new terminal window) CLI POC Proof of concept for Command Line Interface 2022 Q1 Milestone Description GOTO Console Open links to online console for Azure/GCP/Alibaba. AWS Multi-Console Extension Browser extension to enable concurrent login with different roles on online consoles ( demo video ). CLI Full support for Leapp Command Line Interface. Export to ENV Export temporary credentials to environment variables (inject in new terminal window) for Azure/GCP/Alibaba. Custom Integrations Develop your own Integration . GUI Refactoring A new, cooler and more usable graphical user interface. 2022 Q2 Milestone Description Multi-Console Extension Browser extension to log in with different entities on online consoles for Azure/GCP/Alibaba. AWS Metadata Server Redirect to Leapp metadata requests to make your local environment the same as an EC2, Container or Lambda. DIRENV Support Automatically switch credentials in terminal when entering a project folder. Leapp PRO 2022 Q1 Release Leapp PRO for individuals (SaaS). Milestone Description Online Configuration Save your configuration online with a Zero Knowledge approach. Nobody will be able to see them (not even us). PULL/PUSH Sync online configuration on unlimited devices. MFA Multi-factor authentication to login. Unique Session Logout in case of concurrent login from another device. Concurrent Access Check Notify email on login attempt on another device while already logged in. Geolocation Check Notify email on login attempt on change of geolocation. Leapp Team 2022 Q2 Release Leapp for Teams (SaaS). Include PRO features for all team members. Milestone Description Import Configurations Import current configured Sessions as base for sharing. Invite Team Members Invite other devs from your organization. Share Sessions Share Sessions to other team members in your organization. 2022 Q3 Release Leapp for Teams (on-premise). Milestone Description On Premise Leapp for Teams Install Leapp for Teams in your own infrastructure. Automatic Side Effects Automatically change relevant permissions to give/take access.","title":"Roadmap"},{"location":"roadmap/#leapp","text":"","title":"Leapp"},{"location":"roadmap/#2021-q4","text":"Milestone Description AWS GOTO Console Open links to online console for AWS AWS External IDs Support AWS External IDS in Sessions AWS Export to ENV Export temporary credentials to environment variables (inject in new terminal window) CLI POC Proof of concept for Command Line Interface","title":"2021 Q4"},{"location":"roadmap/#2022-q1","text":"Milestone Description GOTO Console Open links to online console for Azure/GCP/Alibaba. AWS Multi-Console Extension Browser extension to enable concurrent login with different roles on online consoles ( demo video ). CLI Full support for Leapp Command Line Interface. Export to ENV Export temporary credentials to environment variables (inject in new terminal window) for Azure/GCP/Alibaba. Custom Integrations Develop your own Integration . GUI Refactoring A new, cooler and more usable graphical user interface.","title":"2022 Q1"},{"location":"roadmap/#2022-q2","text":"Milestone Description Multi-Console Extension Browser extension to log in with different entities on online consoles for Azure/GCP/Alibaba. AWS Metadata Server Redirect to Leapp metadata requests to make your local environment the same as an EC2, Container or Lambda. DIRENV Support Automatically switch credentials in terminal when entering a project folder.","title":"2022 Q2"},{"location":"roadmap/#leapp-pro","text":"","title":"Leapp PRO"},{"location":"roadmap/#2022-q1_1","text":"Release Leapp PRO for individuals (SaaS). Milestone Description Online Configuration Save your configuration online with a Zero Knowledge approach. Nobody will be able to see them (not even us). PULL/PUSH Sync online configuration on unlimited devices. MFA Multi-factor authentication to login. Unique Session Logout in case of concurrent login from another device. Concurrent Access Check Notify email on login attempt on another device while already logged in. Geolocation Check Notify email on login attempt on change of geolocation.","title":"2022 Q1"},{"location":"roadmap/#leapp-team","text":"","title":"Leapp Team"},{"location":"roadmap/#2022-q2_1","text":"Release Leapp for Teams (SaaS). Include PRO features for all team members. Milestone Description Import Configurations Import current configured Sessions as base for sharing. Invite Team Members Invite other devs from your organization. Share Sessions Share Sessions to other team members in your organization.","title":"2022 Q2"},{"location":"roadmap/#2022-q3","text":"Release Leapp for Teams (on-premise). Milestone Description On Premise Leapp for Teams Install Leapp for Teams in your own infrastructure. Automatic Side Effects Automatically change relevant permissions to give/take access.","title":"2022 Q3"},{"location":"sessions/","text":"Sessions A Session contains all the relevant information to let the dev connect to a cloud provider. Three standard actions should be implemented for each session: start , stop , and rotate . Actions Method Description START Make the temporary credentials available to the provider chain STOP Removes the temporary credentials from the provider chain ROTATE Generate new temporary credentials, and substitute the previous ones in the provider chain Session Model Data All Sessions Models shares some basic information, common to all of them. These variables must be defined all the time. Info The process of setting up Leapp Sessions is managed either manually , for each access method, or through integrations with third-party tools. Leapp stores all the Sessions available to the users locally, inside a configuration file called Workspace. ... export class Session { sessionId : string ; sessionName : string ; status : SessionStatus ; startDateTime : string ; region : string ; type : SessionType ; ... } Session Variable Description sessionId Unique identifier to the Session. Is defined at Model instantiation, and represent a unique ID for the session. Every operation involving a specific session must start by getting a session through its sessionId sessionName A fancy name , given at creation by the user, for the Session to make it recognizable at glance. status Represent the State Management of a single session; when the status of a session is active , temporary credentials are available to the user. The possible values are: inactive , pending , active startDateTime A UTC DateTime string representing the last time a specific Session has started; this is useful for rotation and sorting purposes region The AWS Region or Azure Location the Session is working on. For a complete list of AWS Regions go here , and for Azure Locations, go here type Uniquely identifies two important aspects to determine the Session: Cloud Provider and Access Method. . Possible values are: awsIamRoleFederated , awsIamUser , awsIamRoleChained , awsSsoRole , azure . The naming convention we are using is cloudProvider-accessMethod : Cloud Provider on which you are connecting (i.e., AWS, Azure, GCP...), and the Access Method used to generate credentials (i.e., AWS IAM User, Azure Tenant, AWS IAM Role...)","title":"Sessions"},{"location":"sessions/#sessions","text":"A Session contains all the relevant information to let the dev connect to a cloud provider. Three standard actions should be implemented for each session: start , stop , and rotate .","title":"Sessions"},{"location":"sessions/#actions","text":"Method Description START Make the temporary credentials available to the provider chain STOP Removes the temporary credentials from the provider chain ROTATE Generate new temporary credentials, and substitute the previous ones in the provider chain","title":"Actions"},{"location":"sessions/#session-model-data","text":"All Sessions Models shares some basic information, common to all of them. These variables must be defined all the time. Info The process of setting up Leapp Sessions is managed either manually , for each access method, or through integrations with third-party tools. Leapp stores all the Sessions available to the users locally, inside a configuration file called Workspace. ... export class Session { sessionId : string ; sessionName : string ; status : SessionStatus ; startDateTime : string ; region : string ; type : SessionType ; ... } Session Variable Description sessionId Unique identifier to the Session. Is defined at Model instantiation, and represent a unique ID for the session. Every operation involving a specific session must start by getting a session through its sessionId sessionName A fancy name , given at creation by the user, for the Session to make it recognizable at glance. status Represent the State Management of a single session; when the status of a session is active , temporary credentials are available to the user. The possible values are: inactive , pending , active startDateTime A UTC DateTime string representing the last time a specific Session has started; this is useful for rotation and sorting purposes region The AWS Region or Azure Location the Session is working on. For a complete list of AWS Regions go here , and for Azure Locations, go here type Uniquely identifies two important aspects to determine the Session: Cloud Provider and Access Method. . Possible values are: awsIamRoleFederated , awsIamUser , awsIamRoleChained , awsSsoRole , azure . The naming convention we are using is cloudProvider-accessMethod : Cloud Provider on which you are connecting (i.e., AWS, Azure, GCP...), and the Access Method used to generate credentials (i.e., AWS IAM User, Azure Tenant, AWS IAM Role...)","title":"Session Model Data"},{"location":"built-in-features/aws-ec2-connect/","text":"You can directly connect from Leapp to an AWS EC2 instance through AWS System Manager (AWS SSM). Info To setup SSM follow THIS guide. Warning If the user is not granted the right permissions, the operation will fail and Leapp will throw an error message.>","title":"EC2 connect through AWS SSM"},{"location":"built-in-features/aws-named-profiles/","text":"With Leapp you can group and activate more than one credential set at a time through Named Profiles . Named Profiles Named Profiles are a way AWS uses to maintain more than one set of credentials active for you to use with AWS-CLI, SDK, or other third-party tools. Named profiles are stored in ~/.aws/credentials file in the ini file format. Named Profiles have a default profile which is the one you get from aws configure command. Create a new Named Profile Named Profiles can be created in 3 ways : Option Panel When creating a new Session Edit Profile in Contextual Menu Click on the hamburger icon and go to Options . Find the Named profiles tab, and click on the plus icon. When creating a new session a selector will be available to choose or add a new profile. Click on the kebab icon and select edit profile an option to select or add a new profile will be available. Info Named Profiles are selectable directly when creating an AWS access method (IAM Federated Role, IAM Chained Role, IAM User or IAM SSO Role), by using the selector provided in the form. It is also possible to create a new named profile directly from the selector by typing a new name and by pressing ENTER key. The new name is directly added to the named profile list and it will be possible to use it for other sessions too. AWS SSO sessions will have default as named profile when obtained through Login or Sync, to change the named profile associated to a session you have to use the \"Change Profile\" option in the session list. Named Profile List Named profiles can be managed from the option page. Here you can add or edit a new named profile, you can also remove unwanted named profiles. When removing a named profile, Leapp will give you a hint on modified sessions, and those sessions will be reverted to default named profile. The input form can be used for adding or editing a named profile: when empty you can use it to add a new named profile. When selecting the (edit) button, the input field will be filled and you can change the name of the named profile associated with all sessions already linked to that profile. Session Options A named profile can also be changed directly from an AWS session element in the main list. There you can add or select a new named profile the same way you would from the add session form. Remember that when you change a session's profile the session is put immediately in stop mode, that's because we have changed the credential file, so you'll need to restart it again.","title":"AWS Multi-profile management"},{"location":"built-in-features/aws-named-profiles/#named-profiles","text":"Named Profiles are a way AWS uses to maintain more than one set of credentials active for you to use with AWS-CLI, SDK, or other third-party tools. Named profiles are stored in ~/.aws/credentials file in the ini file format. Named Profiles have a default profile which is the one you get from aws configure command.","title":"Named Profiles"},{"location":"built-in-features/aws-named-profiles/#create-a-new-named-profile","text":"Named Profiles can be created in 3 ways : Option Panel When creating a new Session Edit Profile in Contextual Menu Click on the hamburger icon and go to Options . Find the Named profiles tab, and click on the plus icon. When creating a new session a selector will be available to choose or add a new profile. Click on the kebab icon and select edit profile an option to select or add a new profile will be available. Info Named Profiles are selectable directly when creating an AWS access method (IAM Federated Role, IAM Chained Role, IAM User or IAM SSO Role), by using the selector provided in the form. It is also possible to create a new named profile directly from the selector by typing a new name and by pressing ENTER key. The new name is directly added to the named profile list and it will be possible to use it for other sessions too. AWS SSO sessions will have default as named profile when obtained through Login or Sync, to change the named profile associated to a session you have to use the \"Change Profile\" option in the session list. Named Profile List Named profiles can be managed from the option page. Here you can add or edit a new named profile, you can also remove unwanted named profiles. When removing a named profile, Leapp will give you a hint on modified sessions, and those sessions will be reverted to default named profile. The input form can be used for adding or editing a named profile: when empty you can use it to add a new named profile. When selecting the (edit) button, the input field will be filled and you can change the name of the named profile associated with all sessions already linked to that profile. Session Options A named profile can also be changed directly from an AWS session element in the main list. There you can add or select a new named profile the same way you would from the add session form. Remember that when you change a session's profile the session is put immediately in stop mode, that's because we have changed the credential file, so you'll need to restart it again.","title":"Create a new Named Profile"},{"location":"configuring-integration/configure-aws-single-sign-on-integration/","text":"AWS Single Sign-On (AWS SSO) is a cloud service that allows you to grant your users access to AWS resources across multiple AWS accounts. AWS SSO provides a directory that you can use to create users, organize them in groups, and set permissions across those groups; or you can bring them from your Microsoft Active Directory or a standards-based identity provider, such as Okta Universal Directory or Azure AD. After logging in the first-time, Leapp will map all your roles and users into Sessions. Info To get started in using AWS SSO refer to this guide . Fields Field Description AWS SSO URL The portal URL to begin the authentication flow. It's usually in the form d-xxxxxxxxxx.awsapps.com/start . REGION The region on which AWS SSO is administered and configured. This is NOT where your generated credentials will be valid, it's only used for login. Video Tutorial","title":"Configure AWS Single Sign-On integration"},{"location":"configuring-integration/configure-aws-single-sign-on-integration/#fields","text":"Field Description AWS SSO URL The portal URL to begin the authentication flow. It's usually in the form d-xxxxxxxxxx.awsapps.com/start . REGION The region on which AWS SSO is administered and configured. This is NOT where your generated credentials will be valid, it's only used for login.","title":"Fields"},{"location":"configuring-integration/configure-aws-single-sign-on-integration/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"configuring-session/configure-aws-iam-role-chained/","text":"An IAM role has some similarities to an IAM user. Roles and users are both AWS identities with permissions policies that determine what the identity can and cannot do in AWS. However, instead of being uniquely associated with one person, a role is intended to be assumable by anyone who needs it. A role does not have standard long-term credentials such as a password or access keys associated with it. Instead, when you assume a role, it provides you with temporary security credentials for your role session. Role chaining occurs when you use a role to assume a second role through the AWS CLI or API, even in other accounts. Info Refer to this guide to delegate access across AWS accounts using IAM Roles chaining. Fields Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. NAMED PROFILE Your friendly session name in the AWS credential file. You will be able to reference from the AWS CLI with the --name . REGION Your default region of choice. Select the one which you use the most for this Session. ROLE ARN Your IAM Role unique ID. The active Session will refer to this Role. ROLE SESSION NAME Your session name. You can query and search this on AWS Cloudtrail or any other linked audit service to find out what action were performed by the linked Identity. ASSUMER SESSION Your session from which this Role will be assumed. The assume-role call will be automatically made by Leapp. Video Tutorial","title":"Configure AWS IAM Role Chained"},{"location":"configuring-session/configure-aws-iam-role-chained/#fields","text":"Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. NAMED PROFILE Your friendly session name in the AWS credential file. You will be able to reference from the AWS CLI with the --name . REGION Your default region of choice. Select the one which you use the most for this Session. ROLE ARN Your IAM Role unique ID. The active Session will refer to this Role. ROLE SESSION NAME Your session name. You can query and search this on AWS Cloudtrail or any other linked audit service to find out what action were performed by the linked Identity. ASSUMER SESSION Your session from which this Role will be assumed. The assume-role call will be automatically made by Leapp.","title":"Fields"},{"location":"configuring-session/configure-aws-iam-role-chained/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"configuring-session/configure-aws-iam-role-federated/","text":"AWS Identity and Access Management (IAM) supports identity federation for delegated access to the AWS Management Console or AWS APIs. With identity federation, external identities are granted secure access to resources in your AWS accounts through IAM roles. These external identities can come from your corporate identity provider (such as Microsoft Active Directory or from the AWS Directory Service) or from a web identity provider (such as Amazon Cognito, Login with Amazon, Facebook, Google, or any OpenID Connect-compatible provider). We currently support only SAML 2.0 federation. Info Refer to this guide to provision your own federated roles. Refer to this guide to configure and trust your SAML 2.0 Identity Provider. Supported SAML Identity Providers Identity Provider AWS Azure GSUITE OKTA ONELOGIN AZURE AD Fields Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. NAMED PROFILE Your friendly session name in the AWS credential file. You will be able to reference from the AWS CLI with the --name . REGION Your default region of choice. Select the one which you use the most for this Session. SAML 2.0 URL Your SAML URL interface to start the authentication flow to log in your Identity provider. AWS IDENTIY PROVIDER ARN Your Identity Provider ID in AWS. You can find it in IAM section Identity Providers. Video tutorial AWS IAM Federated Role Access Use Case","title":"Configure AWS IAM Role Federated"},{"location":"configuring-session/configure-aws-iam-role-federated/#supported-saml-identity-providers","text":"Identity Provider AWS Azure GSUITE OKTA ONELOGIN AZURE AD","title":"Supported SAML Identity Providers"},{"location":"configuring-session/configure-aws-iam-role-federated/#fields","text":"Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. NAMED PROFILE Your friendly session name in the AWS credential file. You will be able to reference from the AWS CLI with the --name . REGION Your default region of choice. Select the one which you use the most for this Session. SAML 2.0 URL Your SAML URL interface to start the authentication flow to log in your Identity provider. AWS IDENTIY PROVIDER ARN Your Identity Provider ID in AWS. You can find it in IAM section Identity Providers.","title":"Fields"},{"location":"configuring-session/configure-aws-iam-role-federated/#video-tutorial","text":"AWS IAM Federated Role Access Use Case","title":"Video tutorial"},{"location":"configuring-session/configure-aws-iam-user/","text":"An AWS Identity and Access Management (IAM) user is an entity that you create in AWS to represent the person or application that uses it to interact with AWS. A IAM User in AWS consists of a name and a set of long-term credentials. Leapp never set these values in the configuration files, and automatically generates and refresh a set of short-term credentials to make available. Info If you want to know how Leapp generates and refresh short-term credentials refer to the credentials generation section in the documentation. Fields Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. NAMED PROFILE Your friendly session name in the AWS credential file. You will be able to reference from the AWS CLI with the --name . REGION Your default region of choice. Select the one which you use the most for this Session. MFA DEVICE ARN Your MFA device ID to set up multi-factor authentication. See below how to achieve that. ACCESS KEY ID Your long-term Access Key. It will be used to generate a short-term set of credentials. Don't disclose it to anyone. SECRET ACCESS KEY Your long-term Secret Key. It will be used to generate a short-term set of credentials. Don't disclose it to anyone. Video Tutorial","title":"Configure AWS IAM User"},{"location":"configuring-session/configure-aws-iam-user/#fields","text":"Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. NAMED PROFILE Your friendly session name in the AWS credential file. You will be able to reference from the AWS CLI with the --name . REGION Your default region of choice. Select the one which you use the most for this Session. MFA DEVICE ARN Your MFA device ID to set up multi-factor authentication. See below how to achieve that. ACCESS KEY ID Your long-term Access Key. It will be used to generate a short-term set of credentials. Don't disclose it to anyone. SECRET ACCESS KEY Your long-term Secret Key. It will be used to generate a short-term set of credentials. Don't disclose it to anyone.","title":"Fields"},{"location":"configuring-session/configure-aws-iam-user/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"configuring-session/configure-azure-tenant/","text":"A dedicated and trusted instance of Azure AD that's automatically created when your organization signs up for a Microsoft cloud service subscription, such as Microsoft Azure, Microsoft Intune, or Microsoft 365. An Azure tenant represents a single organization. An Azure Tenant consists of a name and a set of long-term credentials. Info Leapp enhances security of Azure credentials by removing refresh token from accessTokens.json file which could potentially allow an attacker accessing a User's PC to regenerate valid credentials even if a valid access token is not present and by rotating Azure access token. Fields Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. TENANT ID A tenant ID identifies a tenant. You can have multiple clients on a given tenant database. SUBSCRIPTION ID The subscription ID is a unique alphanumeric string that identifies your Azure subscription. LOCATION The Azure datacenters are located around the world in strategic places that best meets the customer demands. These areas are known as Azure locations. Specific services requires the user to select a specific location. Video Tutorial","title":"Configure Azure Tenant"},{"location":"configuring-session/configure-azure-tenant/#fields","text":"Field Description ALIAS Your friendly session name in Leapp. Give it a meaningful name so it will be easier to search for it inside Leapp. TENANT ID A tenant ID identifies a tenant. You can have multiple clients on a given tenant database. SUBSCRIPTION ID The subscription ID is a unique alphanumeric string that identifies your Azure subscription. LOCATION The Azure datacenters are located around the world in strategic places that best meets the customer demands. These areas are known as Azure locations. Specific services requires the user to select a specific location.","title":"Fields"},{"location":"configuring-session/configure-azure-tenant/#video-tutorial","text":"","title":"Video Tutorial"},{"location":"contributing/get-involved/","text":"Get involved Contributions and questions are not just welcome, they\u2019re essential! Please open issues with ideas on how to improve Leapp, including feedbacks, critiques, and information about how you\u2019re using it. Discussion is at the heart of the project and your thoughts and idea will help make it better for everyone, thank you. Read our contribution guide to learn more. You can chat with us inside our community so join us, or feel free to contact us via the website ! Join our Community","title":"Get involved"},{"location":"contributing/get-involved/#get-involved","text":"Contributions and questions are not just welcome, they\u2019re essential! Please open issues with ideas on how to improve Leapp, including feedbacks, critiques, and information about how you\u2019re using it. Discussion is at the heart of the project and your thoughts and idea will help make it better for everyone, thank you. Read our contribution guide to learn more. You can chat with us inside our community so join us, or feel free to contact us via the website ! Join our Community","title":"Get involved"},{"location":"contributing/project-structure/","text":"Overview To allow what is proposed in the Specs, Leapp's project is built on a set of services that realize the basic functionalities . The actual project's structure is structured to allow developers to contribute to source code in the most easier and atomic way possible. In particular, we want to focus the attention on the development of Session Service patterns: Session Service Pattern A specific service manages the way each type of Session will handle the process of credentials generation. There is a three-level abstraction implementation for this kind of service: A general Session Service is the top level of abstraction of a Session, it implements the state management of any Session in the app and has three abstract methods for Start, Stop, and Rotate. A Provider Session Service (i.e., AWSSessionService ) extends the general session service and handles credentials for a specific Cloud Provider to Start, Stop, and Rotate each Session of this type. This level of abstraction unifies all the common actions for all the Access Methods within a Cloud Provider. A Provider Access Method Service (i.e., AWSIAMUserService ) is the concrete implementation of all the information needed to generate the credentials for a specific Access Method. It implements both CRUD methods and the specific steps to generate credentials for a given Access Method. AWS example Leapp manages on behalf of a user the ~./aws/credentials file. It leverages Start , Stop , and Rotate methods from basic Session Service to add, remove, or renew temporary credentials in the file. Based on the Session Service Pattern, we created the Aws Session Service to extend basic Session Service for AWS . AwsSessionService (Provider Service) AwsSessionService was created because all the Access Methods for AWS implemented in Leapp shares a common code structure for Start , Stop , and Rotate . AwsSessionService defines three abstract methods, that must be implemented by every Access Methods of AWS . They are: generateCredentials applyCredentials deApplyCredentials async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} Let's check Start, Stop, and Rotate in detail. Start() The start method is called when a user clicks on an AWS session in the Session List in the Client UI, and it marks the activation of a session thus generating and applying new temporary credentials. async start(sessionId: string): Promise<void> { try { this.stopAllWithSameNameProfile(sessionId); this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId);** **await this.applyCredentials(sessionId, credentialsInfo);** this.sessionActivate(sessionId); } catch (error) { this.sessionError(sessionId, error); } } Start method accept a sessionId parameter to retrieve the session to activate . Above is how the Start method is coded in AWS Session Service by means of a template . Using a template ensures that every Access Method for AWS, will need to implement only some specific parts of the code, without compromising the general logic. The steps included are: Stop all sessions with the same name profile - only one session can be activated with a specific profile name at a time. Put Session state to loadingInBrowser . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active using sessionActivate() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Rotate() async rotate(sessionId: string): Promise<void> { try { this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId); await this.applyCredentials(sessionId, credentialsInfo);** this.sessionRotated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } A similar approach to Start is used with Rotate. Rotate() is called by the Client every time a session is expired (temporary credentials are no longer valid). Calling Rotate will generate a new set of temporary credentials, replacing the old ones. The steps included are: Put Session state to loadingInBrowser . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active by calling the sessionRotated() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Stop() async stop(sessionId: string): Promise<void> { try { **await this.deApplyCredentials(sessionId);** this.sessionDeactivated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } The Stop method happens when an error occurs during a call or when the user clicks on an active session . In this case, we de-apply temporary credentials, which in the case of AWS, means removing them from the credential file. Steps here are: De-apply credentials - this method is overridden by specific implementations of Access Methods, usually involving operations other than removing credentials from credentials file, like removing sensible information from your Secret Vault because they are no longer used. Deactivate the session - which involves putting the Session' state to inactive . The Session will be moved from active session list to general session list in the UI . As always in case of error, we send general error information to the UI and to the log file via sessionError . To conclude, each Access Method has a specific service that extends AwsSessionService implementing these 3 common methods (generate, apply, and de-apply) . Access Method Session Service An Access Method generates credentials for the User access to a Cloud Provider , for example, in AWS we have different access methods: AWS IAM Users AWS IAM Roles Federated AWS IAM Role Chained AWS SSO Role. Each access method service implements actions to Create , Delete , and Edit this specific Session Type. As the first thing we need to create an interface of all the required information to a specific Access Method: export interface AwsPlainSessionRequest { accountName: string; accessKey: string; secretKey: string; region: string; mfaDevice?: string; } To set up a specific session from an Access Method we have to create it with a Create method, which uses the interface previously defined: create(accountRequest: AwsPlainSessionRequest, profileId: string): void { const session = new AwsPlainSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } At the moment edit and delete are defined generally in SessionService , so no need to implement them in an Access Method. To allow using other services to construct our logic we define them in the constructor of the service class. constructor( protected workspaceService: WorkspaceService, private keychainService: KeychainService, private appService: AppService, private fileService: FileService) { super(workspaceService); } We also need to define a super(workspaceService) as we are extending AwsSessionService, and thus its constructor. To fulfill its tasks an Access Method must extend AwsSessionService ; doing so, will require to implement these three methods: async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} They are mandatory , but besides them, a Developer can add to the service class every private or static method he/she would like to organize the code. We present AWS IAM Users Access Method implementation as an example . AWS IAM Users Access Method Below we present all the methods implemented in the AWS IAM User Access Method; its purpose is to build temporary IAM STS credentials starting from a standard IAM User credential set. The Set is stored securely upon session creation in the OS Vault and is used at runtime, and only here to generate valid IAM STS temporary credentials. Let's start with two helper methods: static isTokenExpired(tokenExpiration: string): boolean { const now = Date.now(); return now > new Date(tokenExpiration).getTime(); } With isTokenExpired we check the SessionToken expiration given with the temporary credentials to see if they are still valid or not (thus the method returning a boolean). static sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse: GetSessionTokenResponse): { sessionToken: any } { return { sessionToken: { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: getSessionTokenResponse.Credentials.AccessKeyId.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: getSessionTokenResponse.Credentials.SecretAccessKey.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: getSessionTokenResponse.Credentials.SessionToken.trim(), } }; } The second helper method constructs a CredentialInfo object to return to the AWSSessionService template for Start () and Rotate (). It is called at the end of the generateCredentials () *method *. It has the SessionTokenResponse from the STS client as the input parameter. It maps all the relevant attributes to the returned object. create(accountRequest: AwsIamUserSessionRequest, profileId: string): void { const session = new AwsIamUserSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } Create() is used to construct a new Session as explained before. It calls for a new AwsIamUserSession , passing the properties retrieved from the UI form. A Developer will define a new Model for a Session and that new model will be used here, in case he/she wants to create a new Access Method. In this particular case we also save the static credentials in the OS Vault using the KeyChain service, which makes saving and retrieving secrets from the vault transparent to the developer. Finally, we add the session to the workspace (our configuration object). async generateCredentials(sessionId: string): Promise<CredentialsInfo> { // Get the session in question const session = this.get(sessionId); // Retrieve session token expiration const tokenExpiration = (session as AwsIamUserSession).sessionTokenExpiration; // Check if token is expired if (!tokenExpiration || AwsIamUserService.isTokenExpired(tokenExpiration)) { // Token is Expired! // Retrieve access keys from keychain const accessKeyId = await this.getAccessKeyFromKeychain(sessionId); const secretAccessKey = await this.getSecretKeyFromKeychain(sessionId); // Get session token // https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html AWS.config.update({ accessKeyId, secretAccessKey }); // Configure sts client options const sts = new AWS.STS(this.appService.stsOptions(session)); // Configure sts get-session-token api call params // eslint-disable-next-line @typescript-eslint/naming-convention const params = { DurationSeconds: environment.sessionTokenDuration }; // Check if MFA is needed or not if ((session as AwsIamUserSession).mfaDevice) { // Return session token after calling MFA modal return this.generateSessionTokenCallingMfaModal(session, sts, params); } else { // Return session token in the form of CredentialsInfo return this.generateSessionToken(session, sts, params); } } else { // Session Token is NOT expired try { // Retrieve session token from keychain return JSON.parse(await this.keychainService.getSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`)); } catch (err) { throw new LeappParseError(this, err.message); } } } The first of the abstract methods we need to implement in the Access Method Service. We use this to generate credentials and return them in the form of a Javascript Promise - because the procedure is potentially not immediate and asynchronous. We retrieve the session previously created using the sessionId , which is passed as a parameter; from there we check its token expiration to see if we need to generate new credentials or reuse the one previously created. If we already have a valid session token, we retrieve it from the OS vault, parse the JSON string to construct a valid object to return for further processing. Note that when the return type is a Promise, any normal object will be directly cast to Promise . If we don't have any token expiration property (first generation) or the token is expired, we retrieve static credentials from the OS vault and use them in combination with the IAM STS client to generate a new Session Token with temporary credentials using this.generateSessionToken(session, sts, params); In case we have configured Multi-Factor Authentication, we call for a helper method to show a modal window, retrieve the MFA code, add it to the STS parameters and then obtain the session token. private generateSessionTokenCallingMfaModal( session: Session, sts: AWS.STS, params: { DurationSeconds: number }): Promise<CredentialsInfo> { return new Promise((resolve, reject) => { this.appService.inputDialog('MFA Code insert', 'Insert MFA Code', 'please insert MFA code from your app or device', (value) => { if (value !== Constants.confirmClosed) { params['SerialNumber'] = (session as AwsIamUserSession).mfaDevice; params['TokenCode'] = value; // Return session token in the form of CredentialsInfo resolve(this.generateSessionToken(session, sts, params)); } else { reject(new LeappMissingMfaTokenError(this, 'Missing Multi Factor Authentication code')); } }); }); } We can see that we return a promise to adhere to the generateCredentials signature. async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialObject = {}; credentialObject[profileName] = { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: credentialsInfo.sessionToken.aws_access_key_id, // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: credentialsInfo.sessionToken.aws_secret_access_key, // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: credentialsInfo.sessionToken.aws_session_token, region: session.region }; return await this.fileService.iniWriteSync(this.appService.awsCredentialPath(), credentialObject); } Applying credentials is just a matter of getting the current profile name for the session, construct a suitable credential object using the profile name and the CredentialInfo object from generateCredentials and write it in the AWS credential file. async deApplyCredentials(sessionId: string): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialsFile = await this.fileService.iniParseSync(this.appService.awsCredentialPath()); delete credentialsFile[profileName]; return await this.fileService.replaceWriteSync(this.appService.awsCredentialPath(), credentialsFile); } To de-apply a credential we retrieve its profile name and use it to find and remove the credential set from the credential file. private async getAccessKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-access-key-id`); } private async getSecretKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-secret-access-key`); } private async generateSessionToken(session: Session, sts: AWS.STS, params: any): Promise<CredentialsInfo> { try { // Invoke sts get-session-token api const getSessionTokenResponse: GetSessionTokenResponse = await sts.getSessionToken(params).promise(); // Save session token expiration this.saveSessionTokenResponseInTheSession(session, getSessionTokenResponse); // Generate correct object from session token response const sessionToken = AwsIamUserService.sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse); // Save in keychain the session token await this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`, JSON.stringify(sessionToken)); // Return Session Token return sessionToken; } catch (err) { throw new LeappAwsStsError(this, err.message); } } The first two methods are used to simplify getting secrets in the OS vault. generateSessionToken () is used to call STS for generating a new session, save the expiration time from token in the session, save the session token in the OS vault and finally return the session token for further processing. private saveSessionTokenResponseInTheSession(session: Session, getSessionTokenResponse: AWS.STS.GetSessionTokenResponse): void { const index = this.workspaceService.sessions.indexOf(session); const currentSession: Session = this.workspaceService.sessions[index]; (currentSession as AwsIamUserSession).sessionTokenExpiration = getSessionTokenResponse.Credentials.Expiration.toISOString(); this.workspaceService.sessions[index] = currentSession; this.workspaceService.sessions = [...this.workspaceService.sessions]; } This helper method is used to extract the session token expiration and save it as a property of the session object to later use it in case of a further generation of credentials, both during a rotation event or a manual re-apply.","title":"Project structure"},{"location":"contributing/project-structure/#overview","text":"To allow what is proposed in the Specs, Leapp's project is built on a set of services that realize the basic functionalities . The actual project's structure is structured to allow developers to contribute to source code in the most easier and atomic way possible. In particular, we want to focus the attention on the development of Session Service patterns:","title":"Overview"},{"location":"contributing/project-structure/#session-service-pattern","text":"A specific service manages the way each type of Session will handle the process of credentials generation. There is a three-level abstraction implementation for this kind of service: A general Session Service is the top level of abstraction of a Session, it implements the state management of any Session in the app and has three abstract methods for Start, Stop, and Rotate. A Provider Session Service (i.e., AWSSessionService ) extends the general session service and handles credentials for a specific Cloud Provider to Start, Stop, and Rotate each Session of this type. This level of abstraction unifies all the common actions for all the Access Methods within a Cloud Provider. A Provider Access Method Service (i.e., AWSIAMUserService ) is the concrete implementation of all the information needed to generate the credentials for a specific Access Method. It implements both CRUD methods and the specific steps to generate credentials for a given Access Method.","title":"Session Service Pattern"},{"location":"contributing/project-structure/#aws-example","text":"Leapp manages on behalf of a user the ~./aws/credentials file. It leverages Start , Stop , and Rotate methods from basic Session Service to add, remove, or renew temporary credentials in the file. Based on the Session Service Pattern, we created the Aws Session Service to extend basic Session Service for AWS .","title":"AWS example"},{"location":"contributing/project-structure/#awssessionservice-provider-service","text":"AwsSessionService was created because all the Access Methods for AWS implemented in Leapp shares a common code structure for Start , Stop , and Rotate . AwsSessionService defines three abstract methods, that must be implemented by every Access Methods of AWS . They are: generateCredentials applyCredentials deApplyCredentials async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} Let's check Start, Stop, and Rotate in detail. Start() The start method is called when a user clicks on an AWS session in the Session List in the Client UI, and it marks the activation of a session thus generating and applying new temporary credentials. async start(sessionId: string): Promise<void> { try { this.stopAllWithSameNameProfile(sessionId); this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId);** **await this.applyCredentials(sessionId, credentialsInfo);** this.sessionActivate(sessionId); } catch (error) { this.sessionError(sessionId, error); } } Start method accept a sessionId parameter to retrieve the session to activate . Above is how the Start method is coded in AWS Session Service by means of a template . Using a template ensures that every Access Method for AWS, will need to implement only some specific parts of the code, without compromising the general logic. The steps included are: Stop all sessions with the same name profile - only one session can be activated with a specific profile name at a time. Put Session state to loadingInBrowser . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active using sessionActivate() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Rotate() async rotate(sessionId: string): Promise<void> { try { this.sessionLoading(sessionId); **const credentialsInfo = await this.generateCredentials(sessionId); await this.applyCredentials(sessionId, credentialsInfo);** this.sessionRotated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } A similar approach to Start is used with Rotate. Rotate() is called by the Client every time a session is expired (temporary credentials are no longer valid). Calling Rotate will generate a new set of temporary credentials, replacing the old ones. The steps included are: Put Session state to loadingInBrowser . Generate a set of new temporary credentials for the given session - this is overridden by the specific Access Method. Once obtained the new temporary credentials apply them - this step is also overridden by Access Methods. Finally set Session state to active by calling the sessionRotated() method. This method will also set the startDateTime to the current Date and Time. In case of an error we call the generic method sessionError which will send relevant error information both to the UI and the log file. Stop() async stop(sessionId: string): Promise<void> { try { **await this.deApplyCredentials(sessionId);** this.sessionDeactivated(sessionId); } catch (error) { this.sessionError(sessionId, error); } } The Stop method happens when an error occurs during a call or when the user clicks on an active session . In this case, we de-apply temporary credentials, which in the case of AWS, means removing them from the credential file. Steps here are: De-apply credentials - this method is overridden by specific implementations of Access Methods, usually involving operations other than removing credentials from credentials file, like removing sensible information from your Secret Vault because they are no longer used. Deactivate the session - which involves putting the Session' state to inactive . The Session will be moved from active session list to general session list in the UI . As always in case of error, we send general error information to the UI and to the log file via sessionError . To conclude, each Access Method has a specific service that extends AwsSessionService implementing these 3 common methods (generate, apply, and de-apply) .","title":"AwsSessionService (Provider Service)"},{"location":"contributing/project-structure/#access-method-session-service","text":"An Access Method generates credentials for the User access to a Cloud Provider , for example, in AWS we have different access methods: AWS IAM Users AWS IAM Roles Federated AWS IAM Role Chained AWS SSO Role. Each access method service implements actions to Create , Delete , and Edit this specific Session Type. As the first thing we need to create an interface of all the required information to a specific Access Method: export interface AwsPlainSessionRequest { accountName: string; accessKey: string; secretKey: string; region: string; mfaDevice?: string; } To set up a specific session from an Access Method we have to create it with a Create method, which uses the interface previously defined: create(accountRequest: AwsPlainSessionRequest, profileId: string): void { const session = new AwsPlainSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-plain-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } At the moment edit and delete are defined generally in SessionService , so no need to implement them in an Access Method. To allow using other services to construct our logic we define them in the constructor of the service class. constructor( protected workspaceService: WorkspaceService, private keychainService: KeychainService, private appService: AppService, private fileService: FileService) { super(workspaceService); } We also need to define a super(workspaceService) as we are extending AwsSessionService, and thus its constructor. To fulfill its tasks an Access Method must extend AwsSessionService ; doing so, will require to implement these three methods: async generateCredentials(sessionId: string): Promise<CredentialsInfo> {} async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> {} async deApplyCredentials(sessionId: string): Promise<void> {} They are mandatory , but besides them, a Developer can add to the service class every private or static method he/she would like to organize the code. We present AWS IAM Users Access Method implementation as an example .","title":"Access Method Session Service"},{"location":"contributing/project-structure/#aws-iam-users-access-method","text":"Below we present all the methods implemented in the AWS IAM User Access Method; its purpose is to build temporary IAM STS credentials starting from a standard IAM User credential set. The Set is stored securely upon session creation in the OS Vault and is used at runtime, and only here to generate valid IAM STS temporary credentials. Let's start with two helper methods: static isTokenExpired(tokenExpiration: string): boolean { const now = Date.now(); return now > new Date(tokenExpiration).getTime(); } With isTokenExpired we check the SessionToken expiration given with the temporary credentials to see if they are still valid or not (thus the method returning a boolean). static sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse: GetSessionTokenResponse): { sessionToken: any } { return { sessionToken: { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: getSessionTokenResponse.Credentials.AccessKeyId.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: getSessionTokenResponse.Credentials.SecretAccessKey.trim(), // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: getSessionTokenResponse.Credentials.SessionToken.trim(), } }; } The second helper method constructs a CredentialInfo object to return to the AWSSessionService template for Start () and Rotate (). It is called at the end of the generateCredentials () *method *. It has the SessionTokenResponse from the STS client as the input parameter. It maps all the relevant attributes to the returned object. create(accountRequest: AwsIamUserSessionRequest, profileId: string): void { const session = new AwsIamUserSession(accountRequest.accountName, accountRequest.region, profileId, accountRequest.mfaDevice); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-access-key-id`, accountRequest.accessKey); this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-secret-access-key`, accountRequest.secretKey); this.workspaceService.addSession(session); } Create() is used to construct a new Session as explained before. It calls for a new AwsIamUserSession , passing the properties retrieved from the UI form. A Developer will define a new Model for a Session and that new model will be used here, in case he/she wants to create a new Access Method. In this particular case we also save the static credentials in the OS Vault using the KeyChain service, which makes saving and retrieving secrets from the vault transparent to the developer. Finally, we add the session to the workspace (our configuration object). async generateCredentials(sessionId: string): Promise<CredentialsInfo> { // Get the session in question const session = this.get(sessionId); // Retrieve session token expiration const tokenExpiration = (session as AwsIamUserSession).sessionTokenExpiration; // Check if token is expired if (!tokenExpiration || AwsIamUserService.isTokenExpired(tokenExpiration)) { // Token is Expired! // Retrieve access keys from keychain const accessKeyId = await this.getAccessKeyFromKeychain(sessionId); const secretAccessKey = await this.getSecretKeyFromKeychain(sessionId); // Get session token // https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html AWS.config.update({ accessKeyId, secretAccessKey }); // Configure sts client options const sts = new AWS.STS(this.appService.stsOptions(session)); // Configure sts get-session-token api call params // eslint-disable-next-line @typescript-eslint/naming-convention const params = { DurationSeconds: environment.sessionTokenDuration }; // Check if MFA is needed or not if ((session as AwsIamUserSession).mfaDevice) { // Return session token after calling MFA modal return this.generateSessionTokenCallingMfaModal(session, sts, params); } else { // Return session token in the form of CredentialsInfo return this.generateSessionToken(session, sts, params); } } else { // Session Token is NOT expired try { // Retrieve session token from keychain return JSON.parse(await this.keychainService.getSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`)); } catch (err) { throw new LeappParseError(this, err.message); } } } The first of the abstract methods we need to implement in the Access Method Service. We use this to generate credentials and return them in the form of a Javascript Promise - because the procedure is potentially not immediate and asynchronous. We retrieve the session previously created using the sessionId , which is passed as a parameter; from there we check its token expiration to see if we need to generate new credentials or reuse the one previously created. If we already have a valid session token, we retrieve it from the OS vault, parse the JSON string to construct a valid object to return for further processing. Note that when the return type is a Promise, any normal object will be directly cast to Promise . If we don't have any token expiration property (first generation) or the token is expired, we retrieve static credentials from the OS vault and use them in combination with the IAM STS client to generate a new Session Token with temporary credentials using this.generateSessionToken(session, sts, params); In case we have configured Multi-Factor Authentication, we call for a helper method to show a modal window, retrieve the MFA code, add it to the STS parameters and then obtain the session token. private generateSessionTokenCallingMfaModal( session: Session, sts: AWS.STS, params: { DurationSeconds: number }): Promise<CredentialsInfo> { return new Promise((resolve, reject) => { this.appService.inputDialog('MFA Code insert', 'Insert MFA Code', 'please insert MFA code from your app or device', (value) => { if (value !== Constants.confirmClosed) { params['SerialNumber'] = (session as AwsIamUserSession).mfaDevice; params['TokenCode'] = value; // Return session token in the form of CredentialsInfo resolve(this.generateSessionToken(session, sts, params)); } else { reject(new LeappMissingMfaTokenError(this, 'Missing Multi Factor Authentication code')); } }); }); } We can see that we return a promise to adhere to the generateCredentials signature. async applyCredentials(sessionId: string, credentialsInfo: CredentialsInfo): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialObject = {}; credentialObject[profileName] = { // eslint-disable-next-line @typescript-eslint/naming-convention aws_access_key_id: credentialsInfo.sessionToken.aws_access_key_id, // eslint-disable-next-line @typescript-eslint/naming-convention aws_secret_access_key: credentialsInfo.sessionToken.aws_secret_access_key, // eslint-disable-next-line @typescript-eslint/naming-convention aws_session_token: credentialsInfo.sessionToken.aws_session_token, region: session.region }; return await this.fileService.iniWriteSync(this.appService.awsCredentialPath(), credentialObject); } Applying credentials is just a matter of getting the current profile name for the session, construct a suitable credential object using the profile name and the CredentialInfo object from generateCredentials and write it in the AWS credential file. async deApplyCredentials(sessionId: string): Promise<void> { const session = this.get(sessionId); const profileName = this.workspaceService.getProfileName((session as AwsIamUserSession).profileId); const credentialsFile = await this.fileService.iniParseSync(this.appService.awsCredentialPath()); delete credentialsFile[profileName]; return await this.fileService.replaceWriteSync(this.appService.awsCredentialPath(), credentialsFile); } To de-apply a credential we retrieve its profile name and use it to find and remove the credential set from the credential file. private async getAccessKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-access-key-id`); } private async getSecretKeyFromKeychain(sessionId: string): Promise<string> { return await this.keychainService.getSecret(environment.appName, `${sessionId}-iam-user-aws-session-secret-access-key`); } private async generateSessionToken(session: Session, sts: AWS.STS, params: any): Promise<CredentialsInfo> { try { // Invoke sts get-session-token api const getSessionTokenResponse: GetSessionTokenResponse = await sts.getSessionToken(params).promise(); // Save session token expiration this.saveSessionTokenResponseInTheSession(session, getSessionTokenResponse); // Generate correct object from session token response const sessionToken = AwsIamUserService.sessionTokenFromGetSessionTokenResponse(getSessionTokenResponse); // Save in keychain the session token await this.keychainService.saveSecret(environment.appName, `${session.sessionId}-iam-user-aws-session-token`, JSON.stringify(sessionToken)); // Return Session Token return sessionToken; } catch (err) { throw new LeappAwsStsError(this, err.message); } } The first two methods are used to simplify getting secrets in the OS vault. generateSessionToken () is used to call STS for generating a new session, save the expiration time from token in the session, save the session token in the OS vault and finally return the session token for further processing. private saveSessionTokenResponseInTheSession(session: Session, getSessionTokenResponse: AWS.STS.GetSessionTokenResponse): void { const index = this.workspaceService.sessions.indexOf(session); const currentSession: Session = this.workspaceService.sessions[index]; (currentSession as AwsIamUserSession).sessionTokenExpiration = getSessionTokenResponse.Credentials.Expiration.toISOString(); this.workspaceService.sessions[index] = currentSession; this.workspaceService.sessions = [...this.workspaceService.sessions]; } This helper method is used to extract the session token expiration and save it as a property of the session object to later use it in case of a further generation of credentials, both during a rotation event or a manual re-apply.","title":"AWS IAM Users Access Method"},{"location":"installation/install-leapp/","text":"Install Leapp MacOS, Windows, and Linux You can install Leapp by downloading the pre-built binaries for your OS in the website release page Download Leapp Unzip the package and double-click on the executable to install. macOS (Homebrew) & Linux (Linuxbrew) Leapp can also be installed on macOS or Linux via Homebrew Cask with: brew install leapp Info Leapp can also be installed with Linuxbrew on Windows via WSL","title":"Install Leapp"},{"location":"installation/install-leapp/#install-leapp","text":"","title":"Install Leapp"},{"location":"installation/install-leapp/#macos-windows-and-linux","text":"You can install Leapp by downloading the pre-built binaries for your OS in the website release page Download Leapp Unzip the package and double-click on the executable to install.","title":"MacOS, Windows, and Linux"},{"location":"installation/install-leapp/#macos-homebrew-linux-linuxbrew","text":"Leapp can also be installed on macOS or Linux via Homebrew Cask with: brew install leapp Info Leapp can also be installed with Linuxbrew on Windows via WSL","title":"macOS (Homebrew) &amp; Linux (Linuxbrew)"},{"location":"installation/requirements/","text":"Requirements MacOS and Windows No requirements are requested for macOS and Windows users. Linux systems Leapp uses libsecret and gnome-keyring as dependencies to store all sensitive data into the keyring. Depending on your distribution you may need to install them before running Leapp using these commands. Arch Linux Debian/Ubuntu Red Hat-based sudo pacman -S gnome-keyring sudo pacman -S libsecret sudo apt-get install gnome-keyring sudo apt-get install libsecret-1-dev sudo yum install gnome-keyring sudo yum install libsecret-devel Logging into EC2 Instances via AWS SSM with Leapp In order to use AWS SSM on your System through Leapp, you must be able to execute this command on your own at least once when suitable credentials are active. aws ssm start-session --region <region> --target <instanceId> If for any reason this command fails, please verify to have Python 3.x installed : https://www.python.org/downloads/ Also verify that the AWS SSM Agent is installed correctly by following the official AWS guide: https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent-v3.html","title":"Requirements"},{"location":"installation/requirements/#requirements","text":"","title":"Requirements"},{"location":"installation/requirements/#macos-and-windows","text":"No requirements are requested for macOS and Windows users.","title":"MacOS and Windows"},{"location":"installation/requirements/#linux-systems","text":"Leapp uses libsecret and gnome-keyring as dependencies to store all sensitive data into the keyring. Depending on your distribution you may need to install them before running Leapp using these commands. Arch Linux Debian/Ubuntu Red Hat-based sudo pacman -S gnome-keyring sudo pacman -S libsecret sudo apt-get install gnome-keyring sudo apt-get install libsecret-1-dev sudo yum install gnome-keyring sudo yum install libsecret-devel","title":"Linux systems"},{"location":"installation/requirements/#logging-into-ec2-instances-via-aws-ssm-with-leapp","text":"In order to use AWS SSM on your System through Leapp, you must be able to execute this command on your own at least once when suitable credentials are active. aws ssm start-session --region <region> --target <instanceId> If for any reason this command fails, please verify to have Python 3.x installed : https://www.python.org/downloads/ Also verify that the AWS SSM Agent is installed correctly by following the official AWS guide: https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent-v3.html","title":"Logging into EC2 Instances via AWS SSM with Leapp"},{"location":"installation/update-leapp/","text":"Update Leapp Leapp checks every 10 minutes (counting from application start) that a new version is available. If so, a dialog message will pop up and show version number , release date and changelog In this modal, a user has the ability to: Remind me later Download update Click on X Leapp will shut down the modal, notify the user that a new update is available by changing the Tray icon (adding a red dot) . Now users will not be bothered anymore until the next release is available. This option is suitable for users that want to stick to a specific version . Note that you can do this for every version and maintain the one you prefer. Leapp will open the Release URL in your default browser to let the User manually download the release for the specific OS and install it. Leapp will close the modal and another one will appear in 10 minutes . macOS (Homebrew), Linux (Linuxbrew) and Windows (via WSL) Leapp can also be updated via Homebrew Cask with: brew upgrade leapp","title":"Update Leapp"},{"location":"installation/update-leapp/#update-leapp","text":"Leapp checks every 10 minutes (counting from application start) that a new version is available. If so, a dialog message will pop up and show version number , release date and changelog In this modal, a user has the ability to: Remind me later Download update Click on X Leapp will shut down the modal, notify the user that a new update is available by changing the Tray icon (adding a red dot) . Now users will not be bothered anymore until the next release is available. This option is suitable for users that want to stick to a specific version . Note that you can do this for every version and maintain the one you prefer. Leapp will open the Release URL in your default browser to let the User manually download the release for the specific OS and install it. Leapp will close the modal and another one will appear in 10 minutes .","title":"Update Leapp"},{"location":"installation/update-leapp/#macos-homebrew-linux-linuxbrew-and-windows-via-wsl","text":"Leapp can also be updated via Homebrew Cask with: brew upgrade leapp","title":"macOS (Homebrew), Linux (Linuxbrew) and Windows (via WSL)"},{"location":"security/intro/","text":"Leapp is built in security-first approach. Every information that requires to be persisted is encrypted and saved on your workstation. We devised two main methods to store data, based on its sensitiveness. Data Persistence and encryption Examples Operational All information used to make Leapp work, not strictly tied to direct access to cloud environments. Stored encrypted in a configuration file in the user workspace. Named profiles, proxy configurations, etc. Sensitive Information that can be used, or potentially exploited, to gain access to cloud environments. Stored in the System Vault, leveraging its own integrated encryption. Static credentials, access tokens, cached data, etc. End-to-end Encryption We leverage Zero-Knowledge to provide end-to-end encryption on tiers that require to save your data outside of your workstation to deliver specific features. Zero Knowledge is designed that no one, except you, can access your secured data. Warning We CAN'T access your data under any circumstances, even if you ask us.","title":"Intro"},{"location":"security/intro/#end-to-end-encryption","text":"We leverage Zero-Knowledge to provide end-to-end encryption on tiers that require to save your data outside of your workstation to deliver specific features. Zero Knowledge is designed that no one, except you, can access your secured data. Warning We CAN'T access your data under any circumstances, even if you ask us.","title":"End-to-end Encryption"},{"location":"security/system-vault/","text":"Information that can be used, or potentially exploited, to gain access to cloud environments are stored your workstation's System Vault, leveraging its own integrated encryption. The user can access at any time the secrets stored in the System Vault through user password. Leapp uses Keytar as an interface to the secure vault on macOS, Windows and Linux systems. Every key is stored in the vault under the name Leapp , in the description you will find the underlying name used by Leapp to retrieve the secret. Supported System Vaults OS System Vault MacOS Keychain Windows Credential Vault Linux API/Libsecret Info We're currently supporting only System Vaults installed by default on the OS. We're planning on extending support to other vaults and online password managers (LastPass, BitWarden, 1Password, etc.). If you'd like other services to be supported feel free to open an Issue or make a Pull Request (check our contributing guidelines ).","title":"System Vault"},{"location":"security/system-vault/#supported-system-vaults","text":"OS System Vault MacOS Keychain Windows Credential Vault Linux API/Libsecret Info We're currently supporting only System Vaults installed by default on the OS. We're planning on extending support to other vaults and online password managers (LastPass, BitWarden, 1Password, etc.). If you'd like other services to be supported feel free to open an Issue or make a Pull Request (check our contributing guidelines ).","title":"Supported System Vaults"},{"location":"security/zero-knowledge/","text":"To persist your configuration online, we implemented Zero-Knowledge encryption to prevent access to your information. But how can you trust a company to keep all of your secrets secret? The answer lies in end-to-end encryption, which lays the groundwork for applications with Zero-Knowledge architectures. Zero-knowledge refers to policies and architecture that eliminate the possibility for secret managers themselves to access your password. Warning This is implemented for saving your configuration online in the PRO and TEAM version of Leapp. You don't know about PRO and TEAM versions? Check our roadmap . Info This same process is leveraged by Bitwarden to store their password. Users have key control When users have complete control of the encryption key, they control access to the data, providing encrypted information to Leapp without Leapp having access to or knowledge of that data. Info To know more about this, you can find the whitepaper on which we based our implementation of Zero-Knowledge end-to-end encryption. Criteria During any phase of the registration and login process the client does not provide any password-related info to the server . - The server does not store any information that can be used to guess the password in a convenient way . In other words, the system must not be prone to brute force or dictionary attacks. - Any sensible data is encrypted client-side , the server will work with encrypted blocks only. - All the implementation is released as open-source**. Technologies PBKDF2 for client hashing. AES 256 for symmetric cypher. RSA with 4096-bit keys for asymmetric cypher. BCrypt for server hashing.","title":"Zero Knowledge"},{"location":"security/zero-knowledge/#users-have-key-control","text":"When users have complete control of the encryption key, they control access to the data, providing encrypted information to Leapp without Leapp having access to or knowledge of that data. Info To know more about this, you can find the whitepaper on which we based our implementation of Zero-Knowledge end-to-end encryption.","title":"Users have key control"},{"location":"security/zero-knowledge/#criteria","text":"During any phase of the registration and login process the client does not provide any password-related info to the server . - The server does not store any information that can be used to guess the password in a convenient way . In other words, the system must not be prone to brute force or dictionary attacks. - Any sensible data is encrypted client-side , the server will work with encrypted blocks only. - All the implementation is released as open-source**.","title":"Criteria"},{"location":"security/zero-knowledge/#technologies","text":"PBKDF2 for client hashing. AES 256 for symmetric cypher. RSA with 4096-bit keys for asymmetric cypher. BCrypt for server hashing.","title":"Technologies"},{"location":"security/credentials-generation/aws/","text":"Leapp manages 4 types of AWS access methods: IAM Federated Role IAM User IAM Single Sign-On IAM Role chained For each access method Leapp generates through STS a set of temporary credentials and a rotation logic is triggered every 20 minutes . Temporary credentials ensures that no long-term credentials are written in the AWS credentials file located in ~/.aws/credentrials . Leapp manages information inserted by the user using the following logic for each access method. IAM Federated Role assumeRoleWithSAML Temporary security credentials created by AssumeRoleWithSAMLResponse last for one hour . However, you can use the optional DurationSeconds parameter to specify the duration of your session. Your role session lasts for the specified duration, or until the time specified in the SAML authentication response's SessionNotOnOrAfter value, whichever is shorter. You can provide a DurationSeconds value from 900 seconds (15 minutes) up to the maximum session duration setting for the role . This setting can have a value from 1 hour to 12 hours . Leapp sets the token duration to 1 hour. Info \u26a0\ufe0f In this case, generated credentials are not \"cached\" in the keychain. IAM Chained Role A IAM Chained Role is used to access another AWS account services through a main session with a trust relationship. https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html If you do not pass DurationSeconds parameter (this is Leapp's case), the temporary credentials expire in 1 hour. IAM User The GetSessionToken operation must be called by using the long-term AWS security credentials of the AWS IAM user, which . Credentials that are created by IAM users are valid for the duration that you specify . This duration can range from 900 seconds (15 minutes) up to a maximum of 129,600 seconds (36 hours) , with a default of 43,200 seconds (12 hours) . Credentials based on account credentials can range from 900 seconds (15 minutes) up to 3,600 seconds (1 hour) , with a default of 1 hour . Leapp sets the token duration to 10 hours. Info These are the only temporary credentials that are stored in the System vault and not rotated, unless expired. AWS SSO Role https://aws.amazon.com/premiumsupport/knowledge-center/sso-temporary-credentials/ Info The access token is valid for 8 hours as noted in the expiresAt timestamp in the JSON file. Expired tokens must re-authenticate using the get-role-credentials API call. Token duration is fixed to 8 hours.","title":"AWS"},{"location":"security/credentials-generation/aws/#iam-federated-role","text":"","title":"IAM Federated Role"},{"location":"security/credentials-generation/aws/#assumerolewithsaml","text":"Temporary security credentials created by AssumeRoleWithSAMLResponse last for one hour . However, you can use the optional DurationSeconds parameter to specify the duration of your session. Your role session lasts for the specified duration, or until the time specified in the SAML authentication response's SessionNotOnOrAfter value, whichever is shorter. You can provide a DurationSeconds value from 900 seconds (15 minutes) up to the maximum session duration setting for the role . This setting can have a value from 1 hour to 12 hours . Leapp sets the token duration to 1 hour. Info \u26a0\ufe0f In this case, generated credentials are not \"cached\" in the keychain.","title":"assumeRoleWithSAML"},{"location":"security/credentials-generation/aws/#iam-chained-role","text":"A IAM Chained Role is used to access another AWS account services through a main session with a trust relationship. https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html If you do not pass DurationSeconds parameter (this is Leapp's case), the temporary credentials expire in 1 hour.","title":"IAM Chained Role"},{"location":"security/credentials-generation/aws/#iam-user","text":"The GetSessionToken operation must be called by using the long-term AWS security credentials of the AWS IAM user, which . Credentials that are created by IAM users are valid for the duration that you specify . This duration can range from 900 seconds (15 minutes) up to a maximum of 129,600 seconds (36 hours) , with a default of 43,200 seconds (12 hours) . Credentials based on account credentials can range from 900 seconds (15 minutes) up to 3,600 seconds (1 hour) , with a default of 1 hour . Leapp sets the token duration to 10 hours. Info These are the only temporary credentials that are stored in the System vault and not rotated, unless expired.","title":"IAM User"},{"location":"security/credentials-generation/aws/#aws-sso-role","text":"https://aws.amazon.com/premiumsupport/knowledge-center/sso-temporary-credentials/ Info The access token is valid for 8 hours as noted in the expiresAt timestamp in the JSON file. Expired tokens must re-authenticate using the get-role-credentials API call. Token duration is fixed to 8 hours.","title":"AWS SSO Role"},{"location":"security/credentials-generation/azure/","text":"Azure credentials generation Azure generates a set of access and refresh tokens that are put inside accessTokens.json inside .azure directory. Following is the procedure used to generate a set of credentials. Access strategy - start session if accessTokens.json is not present Leapp runs az login \u2014tenant <tenant_id> 2>&1 , otherwise accessTokens.json file is parsed and Leapp extracts the access tokens array. if access token - corresponding to the specific tenant - exists, we extract it or else we run az login . if access token is expired we run az account get-access-token --subscription <subscription-id> . Finally az account set \u2014subscription <subscription-id> 2>&1 and az configure \u2014default location <region(location)> are run. Refresh token is deleted from the accessTokens.json file Access strategy - rotate session same as start session Access strategy - stop session We run az account clear , and we set session's status to INACTIVE. Info Leapp enhances security by forcingly refresh access token every 20 minutes and by removing refresh token from the file.","title":"Azure"},{"location":"security/credentials-generation/azure/#azure-credentials-generation","text":"Azure generates a set of access and refresh tokens that are put inside accessTokens.json inside .azure directory. Following is the procedure used to generate a set of credentials.","title":"Azure credentials generation"},{"location":"security/credentials-generation/azure/#access-strategy-start-session","text":"if accessTokens.json is not present Leapp runs az login \u2014tenant <tenant_id> 2>&1 , otherwise accessTokens.json file is parsed and Leapp extracts the access tokens array. if access token - corresponding to the specific tenant - exists, we extract it or else we run az login . if access token is expired we run az account get-access-token --subscription <subscription-id> . Finally az account set \u2014subscription <subscription-id> 2>&1 and az configure \u2014default location <region(location)> are run. Refresh token is deleted from the accessTokens.json file","title":"Access strategy - start session"},{"location":"security/credentials-generation/azure/#access-strategy-rotate-session","text":"same as start session","title":"Access strategy - rotate session"},{"location":"security/credentials-generation/azure/#access-strategy-stop-session","text":"We run az account clear , and we set session's status to INACTIVE. Info Leapp enhances security by forcingly refresh access token every 20 minutes and by removing refresh token from the file.","title":"Access strategy - stop session"},{"location":"troubleshooting/app-data/","text":"Default Leapp directories Here the user can find all the directories that Leapp uses directly or indirectly . Installation path By default, Leapp is installed in the following locations: MacOS Linux Windows /Applications /opt/Leapp C:\\Users\\<USER>\\AppData\\Local\\Programs\\Leapp Configuration files By default, Leapp stores configuration files in the following locations: MacOS Linux Windows ~/.Leapp ~/.Leapp C:\\Users\\<USER>\\.Leapp Info Leapp-lock.json is used to store your actual configuration and is encrypted . .latest contains the latest version of your Leapp application. In case the file is removed accidentally or intentionally it will be recreated on next app restart. Credentials file By default, Leapp writes credentials file in the following locations: MacOS Linux Windows ~/.aws ~/.aws C:\\Users\\<USER>\\.aws Logs file By default, Leapp writes logs to the following locations: MacOS Linux Windows ~/Library/Logs/Leapp/log.log ~/.config/Leapp/log.log %USERPROFILE%\\\\AppData\\\\Roaming\\\\Leapp\\\\log.log Info Logs are structured in the following way: [YYYY-MM-DD HH:mm:ss.mmm] [LEVEL] [rendered/system] [COMPONENT] MESSAGE {Useful Object / Stacktrace Err Object} Warning please always add logs whenever possible to any issue you want to fill to enable the team identify the problem quickly","title":"Application Data"},{"location":"troubleshooting/app-data/#default-leapp-directories","text":"Here the user can find all the directories that Leapp uses directly or indirectly .","title":"Default Leapp directories"},{"location":"troubleshooting/app-data/#installation-path","text":"By default, Leapp is installed in the following locations: MacOS Linux Windows /Applications /opt/Leapp C:\\Users\\<USER>\\AppData\\Local\\Programs\\Leapp","title":"Installation path"},{"location":"troubleshooting/app-data/#configuration-files","text":"By default, Leapp stores configuration files in the following locations: MacOS Linux Windows ~/.Leapp ~/.Leapp C:\\Users\\<USER>\\.Leapp Info Leapp-lock.json is used to store your actual configuration and is encrypted . .latest contains the latest version of your Leapp application. In case the file is removed accidentally or intentionally it will be recreated on next app restart.","title":"Configuration files"},{"location":"troubleshooting/app-data/#credentials-file","text":"By default, Leapp writes credentials file in the following locations: MacOS Linux Windows ~/.aws ~/.aws C:\\Users\\<USER>\\.aws","title":"Credentials file"},{"location":"troubleshooting/app-data/#logs-file","text":"By default, Leapp writes logs to the following locations: MacOS Linux Windows ~/Library/Logs/Leapp/log.log ~/.config/Leapp/log.log %USERPROFILE%\\\\AppData\\\\Roaming\\\\Leapp\\\\log.log Info Logs are structured in the following way: [YYYY-MM-DD HH:mm:ss.mmm] [LEVEL] [rendered/system] [COMPONENT] MESSAGE {Useful Object / Stacktrace Err Object} Warning please always add logs whenever possible to any issue you want to fill to enable the team identify the problem quickly","title":"Logs file"},{"location":"troubleshooting/faq/","text":"I'm using the open-source app, do you store my data online? NO. The open-source software don't transmit, persist, or share anything with other services. All your data are secured and encrypted on your workstation. Nobody can access it, not even ourselves. I've a paid tier, how do you manage my data? Can you access it? We can't and don't want to see any of your access data. We need to store your data online for delivering few features (syncing, managing other users, etc.) but we implement a Zero-Knowledge encryption system that prevent even ourselves to access your data. I don't feel secure using a built-in window for authentication, can't you use the default browser? In the future Leapp will only use the default browser to authenticate. Right now it's a compromise to deliver the authentication flow. We already ported AWS SSO authentication flow on the default browser, and we're working toward migrating the other ones as soon as possible. How can I find Leapp data in the System Vault? Every key stored by Leapp in the vault is named Leapp. The account name shows the description of the element saved by our software. Where do I find Leapp's logs? Head to the [Application data section].","title":"FAQ"},{"location":"troubleshooting/faq/#im-using-the-open-source-app-do-you-store-my-data-online","text":"NO. The open-source software don't transmit, persist, or share anything with other services. All your data are secured and encrypted on your workstation. Nobody can access it, not even ourselves.","title":"I'm using the open-source app, do you store my data online?"},{"location":"troubleshooting/faq/#ive-a-paid-tier-how-do-you-manage-my-data-can-you-access-it","text":"We can't and don't want to see any of your access data. We need to store your data online for delivering few features (syncing, managing other users, etc.) but we implement a Zero-Knowledge encryption system that prevent even ourselves to access your data.","title":"I've a paid tier, how do you manage my data? Can you access it?"},{"location":"troubleshooting/faq/#i-dont-feel-secure-using-a-built-in-window-for-authentication-cant-you-use-the-default-browser","text":"In the future Leapp will only use the default browser to authenticate. Right now it's a compromise to deliver the authentication flow. We already ported AWS SSO authentication flow on the default browser, and we're working toward migrating the other ones as soon as possible.","title":"I don't feel secure using a built-in window for authentication, can't you use the default browser?"},{"location":"troubleshooting/faq/#how-can-i-find-leapp-data-in-the-system-vault","text":"Every key stored by Leapp in the vault is named Leapp. The account name shows the description of the element saved by our software.","title":"How can I find Leapp data in the System Vault?"},{"location":"troubleshooting/faq/#where-do-i-find-leapps-logs","text":"Head to the [Application data section].","title":"Where do I find Leapp's logs?"}]}